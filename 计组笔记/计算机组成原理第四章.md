
计算机组成原理 · 第四章 指令系统
├─ 4.1 指令系统
│  ├─ 4.1.1 指令基本格式
│  │  ├─ 机器指令 = 操作码 + 地址码
│  │  ├─ 按地址码数目分类：零、一、二、三、四地址指令
│  │  ├─ 指令字长 vs 存储字长 vs 机器字长
│  │  └─ 定长/变长指令字结构
│  ├─ 4.1.2 按操作类型分类
│  │  ├─ 数据传送：LOAD / STORE
│  │  ├─ 算术逻辑运算
│  │  ├─ 移位：算术、逻辑、循环
│  │  ├─ 转移：JMP、JZ/JO/JC、CALL/RETURN、Trap
│  │  └─ 输入输出：CPU 寄存器 ↔ IO 端口
│  └─ 4.1.3 扩展操作码
│     ├─ 思想：短码 ≠ 长码前缀；高频短码
│     └─ 计算：上一层留 m 种状态 → 下层扩展 m×2ⁿ 种
│
├─ 4.2 寻址方式
│  ├─ 4.2.1 指令寻址
│  │  ├─ 顺序寻址：PC ← PC + 指令长度
│  │  └─ 跳跃寻址：JMP / CALL 直接改 PC
│  └─ 4.2.2 数据寻址（EA = 有效地址）
│     ├─ 直接：EA = A
│     ├─ 间接：EA = (A)
│     ├─ 寄存器：EA = R
│     ├─ 寄存器间接：EA = (R)
│     ├─ 隐含：操作数地址隐含
│     ├─ 立即：操作数 = A（#）
│     ├─ 基址：EA = (BR) + A
│     ├─ 变址：EA = (IX) + A
│     ├─ 相对：EA = (PC) + A
│     └─ 堆栈：EA = (SP)
│
├─ 4.3 机器级表示（x86 为例）
│  ├─ 4.3.1 x86 汇编语言
│  │  ├─ 寄存器
│  │  │  ├─ 通用：EAX~EDX
│  │  │  ├─ 变址：ESI, EDI
│  │  │  └─ 栈：EBP（底）, ESP（顶）
│  │  └─ 常用指令
│  │     ├─ 数据：mov, push, pop
│  │     ├─ 算术：add, sub, mul, div, inc, dec
│  │     ├─ 逻辑：and, or, not, xor, shl, shr
│  │     └─ 转移：jmp, jxxx（cmp + je/jne/jg...）
│  ├─ 4.3.3 循环
│  │  ├─ 条件跳转实现
│  │  └─ loop 指令（ECX 计数）
│  └─ 4.3.4 函数调用
│     ├─ call / ret
│     │  ├─ call：push IP；jmp 函数入口
│     │  └─ ret：pop IP
│     ├─ 栈帧切换
│     │  ├─ 进入：push ebp; mov ebp, esp
│     │  └─ 退出：mov esp, ebp; pop ebp; ret
│     ├─ 参数 / 返回值
│     │  ├─ 参数：调用者压栈（右→左）
│     │  └─ 返回值：EAX
│     └─ 栈帧布局
│        ├─ 高地址：旧 EBP → 返回地址 → 参数
│        └─ 低地址：局部变量
│
└─ 4.4 CISC vs RISC
   ├─ CISC：复杂指令集，x86 代表
   └─ RISC：精简指令集，ARM/MIPS 代表
      ├─ 指令长度固定
      ├─ Load/Store 体系
      └─ 单周期指令多、硬布线控制   换一个更易记忆的格式

## 4.1 指令系统

### 4.1.1 指令的基本格式

#### 指令的定义
- **指令（又称机器指令）**：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。
- 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。
- **注**：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

#### 指令格式
- 一条指令就是机器语言的一条语句，它是一组有意义的二进制代码。
- 一条指令通常要包括**操作码字段**和**地址码字段**两部分。
  - **操作码（OP）**
  - **地址码（A）**
- 一条指令可能包含 0 个、1 个、2 个、3 个地址码。
- 根据地址码数目不同，可以把指令分为零地址指令、一地址指令、二地址指令、三地址指令和四地址指令。

##### 零地址指令
- **格式**：OP
- **特点**：
  1. 不需要操作数，如空操作、停机、关中断等指令。
  2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。

##### 一地址指令
- **特点**：
  1. 只需要单操作数，如加 1、减 1、取反、求补等。
  2. 需要两个操作数，但某一个操作数隐含在某个寄存器。

##### 二地址指令
- **特点**：常用于需要两个操作数的算法运算、逻辑运算相关指令。

##### 三地址指令
- **特点**：常用于需要两个操作数的算术运算、逻辑运算相关指令。

##### 四地址指令
- **特点**：
  - 正常情况下：取指令之后 PC+1，指向下一条指令。
  - 四地址指令：执行指令后，将 PC 的值修改为 A4 所指向的地址。

#### 地址码的位数影响
- n 位地址码的直接寻址范围 = 2 的 n 次方。
- 若指令总长度固定不变，则地址码数量越多，寻址能力越差。
- **解释**：四地址指令，指令总长度不变，地址码越多，A1~An，每个地址码的位数就要越小，寻址能力就会变差。假如有 n 地址指令，每个地址码位数会很小，无法去非常精确的寻址。

#### 指令字长相关概念
- **指令字长、机器字长、存储字长**：
  - 半字长指令、单字长指令、双字长指令。
  - 指令字长会影响指令所需时间。如：机器字长=存储字长=16bit，则取一次双字长指令需要两次访存。
- **定长指令字结构**：指令系统中所有指令的长度都相等。
- **变长指令字结构**：指令系统中各种指令的长度不等。
- **定长指令字结构 + 可变长操作码**：拓展操作码指令格式。

### 4.1.2 按操作类型分类

1. **数据传送**：
   - **LOAD**：把存储器中的数据放到寄存器中。
   - **STORE**：把寄存器中的数据放到存储器中。
2. **算术逻辑操作**
3. **移位操作**：
   - 算术移位、逻辑移位、循环进位。
4. **转移操作**：
   - **无条件转移**：JMP
   - **条件转移**：
     - JZ：结果为 0
     - JO：结果溢出
     - JC：结果有进位
   - **调用和返回**：CALL 和 RETURN
   - **陷阱(Trap)与陷阱指令**
5. **输入输出操作**：
   - CPU 寄存器与 IO 端口之间的数据传送（端口即 IO 接口中寄存器）。

### 4.1.3 拓展操作码指令格式

#### 拓展操作码举例
- 指令字长为 16 位，每个地址码占 4 位：前 4 位为基本操作码字段 OP，另有 3 个 4 位长的地址字段 A1、A2 和 A3。
- 4 位基本操作码若全部用于三地址指令，则有 16 条。但至少须将 1111 留作拓展操作码之用，即三地址指令为 15 条；
- 1111 1111 留作拓展操作码之用，二地址指令为 15 条；
- 1111 1111 1111 留作拓展操作码之用，一地址指令为 15 条。
- 零地址指令为 16 条。
- 操作码来变，每次都留下操作码全为 1 的操作码留作拓展操作码。

#### 设计拓展操作码指令格式注意事项
1. 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。
- 对使用频率较高的指令，应分配较短的操作码，尽可能减少译码和分析的时间。

#### 拓展操作码计算
- 设地址长度为 n，上一层留出 m 种状态，下一层可拓展出 m * 2 的 n 次方中状态。

#### 指令操作码定义
- 操作码指出指令中该指令应该执行什么性质的操作和具有何种功能。

## 4.2 寻址方式

### 4.2.1 指令寻址
- 按字节编址怎么办？采用变长指令字结构怎么办？PC+1 就不行了，可能是 +n。
- 指令寻址：下一条欲执行指令的地址。该系统采用定长指令字结构，指令字长=存储字长=16bit=2B，主存按字节编址。这时指令与指令之间的内存间距就为 2（因为定长指令结构，按字节编址，存储字长为 2B）。
- 读入一个字，根据操作码判断这条指令的总字节数 n，修改 PC 的值：(PC+n) ----> PC。
- 根据指令的类型，CPU 可能还要进行多次访存，每次读入一个字。
- **顺序寻址**：按顺序执行指令。
- **跳跃寻址**：有转移指令指出，例如：
  ```
  操作码    地址码
  JMP          7
  ```
  无条件转移把 PC 中的内容改为 7。

### 4.2.2 数据寻址

#### 寻址方式概述
- **指令寻址**：下一条欲执行指令的地址，始终由程序计数器 PC 给出。
  - 顺序寻址
  - 跳跃寻址
- **数据寻址**：确定本条指令的地址码指明的真实地址。
- 操作码（OP） + 寻址特征 + 形式地址（A）：求出操作数的真实地址，称为有效地址（EA）。
- 寻址方式位：数据寻址从 0000~1001。
- 假设指令字长=机器字长=存储字长。

#### 数据寻址方式
1. **直接寻址**：
   - 指令字中得到形式地址 A 就是操作数的真实地址 EA。
   - **优点**：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址。
   - **缺点**：A 的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。
2. **间接寻址**：
   - 指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，即 EA=(A)。
   - **优点**：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数），便于编制程序（用间接寻址可以方便地完成子程序返回）。
   - **缺点**：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。
3. **寄存器寻址**：
   - 在指令字中直接给出操作数所在的寄存器编号，即 EA=R，其操作数在由 R 所指的寄存器内。
   - **优点**：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算。
   - **缺点**：寄存器数量不多。
4. **寄存器间接寻址**：
   - 寄存器 R 中给出的不是一个操作数，而是操作数所在主存单元的地址，EA=（R）。
   - **特点**：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存。
5. **隐含寻址**：
   - 不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。
   - **优点**：有利于缩短指令字长。
   - **缺点**：需增加存储操作数或隐含地址的硬件。
6. **立即寻址**：
   - 形式地址 A 就是操作数本身，又称为立即数，一般采用补码形式。`#` 表示立即寻址特征。
   - **优点**：指令执行阶段不访问主存，指令执行时间最短。
   - **缺点**：A 的位数限制了立即数的范围。

#### 数据寻址之偏移寻址
- **基址寻址**：以程序的起始存放地址作为“起点”。
- **变址寻址**：程序员自己决定从哪里作为“起点”。
- **相对寻址**：以程序计数器 PC 所指地址作为“起点”。

7. **基址寻址**：
   - 将 CPU 中基址寄存器（BR）的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 EA=（BR）+A。
   - 采用通用寄存器作为基址寄存器，要在指令中指明哪个通用寄存器作为基址寄存器使用。基址寄存器里存的是起点的地址。
   - **拓展**：程序运行前，CPU 将 BR 的值修改为该程序的起始地址。
   - **优点**：便于程序“浮动”，方便实现多道程序并发进行。基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变。当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。可扩大寻址范围，用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序（整个程序在内存里的浮动）。
8. **变址寻址**：
   - 有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 EA=（IX）+A，其中 IX 可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。
   - **注**：变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（IX 作为偏移量），形式地址 A 不变（作为基地址）。
   - **特点**：变址寻址可以缩短循环相关的指令数。
   - **基址和变址复合寻址**：实际应用中往往需要多种寻址方式复合使用，先基址再变址。
9. **相对寻址**：
   - 把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA=（PC）+A，其中 A 是相对于 PC 所指地址的位移量，可正可负，补码表示。A 是相对于下一个指令地址的位移量。
   - **优点**：操作数地址不是固定的，它能随着 PC 值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动（一段代码在程序内部的浮动）。相对寻址广泛应用于转移指令。
   - **区别**：基址寻址是整个程序在地址的浮动，相对寻址是一段代码在程序内部的浮动。
   - ![相对寻址的作用](https://youke1.picui.cn/s1/2025/08/06/689326bfce5ce.png)
10. **堆栈寻址**：
    - 操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址。
    - 堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。
    - ![数据寻址](https://youke1.picui.cn/s1/2025/08/06/68932dfc3e6c0.webp)

## 4.3 机器级表示

### 4.3.1 x86汇编语言

#### 4.3.1.1 x86汇编语言指令基础
- 高级语言只需关注 x86 汇编语言，题目给出某段简单程序的 C 语言、汇编语言、机器语言表示。能结合 C 语言看懂汇编语言的关键语句。
- 汇编语言、机器语言一一对应，要能结合汇编语言分析机器语言指令的格式和寻址方式。
- **注**：不会考将 C 语言人工翻译成汇编语言。

**指令的作用**：
- 改变程序执行流
- 处理数据

**指令格式**：操作码 + 地址码
- 操作码：怎么处理
- 地址码：数据在哪？
  - 在寄存器里
  - 在主存里
  - 在指令里（立即寻址）

**示例**：
- `mov 目的操作数d，源操作数s`：把源操作数 s 复制到目的操作数 d 所指的位置。

**x86 架构 CPU 寄存器**：
- **EAX~EDX**：通用寄存器，X=未知
- **ESI 和 EDI**：变址寄存器，I 用于线性表、字符串的处理
- **EBP 和 ESP**：
  - EBP 是堆栈基指针
  - ESP 是堆栈顶指针
  - 堆栈寄存器用于实现函数调用

#### 4.3.1.2 常用的 x86 汇编指令
![4.3.4_2_如何访问栈帧(函数调用的机器级表示)PT1M49.792S - 副本.webp](https://youke1.picui.cn/s1/2025/08/06/6893707bd7c85.webp)

**算术运算指令**：
- **加**：`add d, s` - 计算 d+s，结果存入 d
- **减**：`sub d, s` - 计算 d-s，结果存入 d
- **乘**：`mul d, s` - 无符号数 d*s，乘积存入 d
- **除**：`div s` - 无符号除法 edx:eax/s，商存入 eax，余数存入 edx
- **取负数**：`neg d` - 将 d 取负数，结果存入 d
- **自增++**：`inc d` - 将 d++，结果存入 d
- **自减--**：`dec d` - 将 d--，结果存入 d
- **注**：目的操作数 d 不可以是常量

**逻辑运算指令**：
- **与**：`and d, s` - 将 d、s 逐位相与，结果放回 d
- **或**：`or d, s` - 将 d、s 逐位相或，结果放回 d
- **非**：`not d` - 将 d 逐位取反，结果放回 d
- **异或**：`xor d, s` - 将 d、s 逐位异或，结果放回 d
- **左移**：`shl d, s` - 将 d 逻辑左移 s 位，结果放回 d（通常 s 是常量）
- **右移**：`shr d, s` - 将 d 逻辑右移 s 位，结果放回 d

**转移指令**：
- **无条件转移指令**：`jmp <地址>` - PC 无条件转移至 <地址>
  - 示例：`jmp Next` - <地址> 可以用“标号”锚定
  - 标号示例：`Next:` - 用‘标号’锚定位置，特征是有冒号，名字可以自己取
- **条件转移指令**：`jxxx` - 条件转移指令一般要和 `cmp` 指令一起使用
  - `cmp a, b` - 比较 a 和 b 两个数
  - `je` - 若 a== b 则跳转
  - `jne` - 若 a!=b 则跳转
  - `jg` - 若 a>b 则跳转（greater）
  - `jge` - 若 a>=b 则跳转
  - `jl` - 若 a<b 则跳转（less）
  - `jle` - 若 a<=b 则跳转

### 4.3.3 循环语句的机器级表示
- 用条件转移指令可以实现循环
- 用 `loop` 指令实现循环：
  - 示例：
    ```
    mov ecx, 500    ; 用 ecx 作为循环计数器
    Looptop:        ; 循环的开始
    ; 循环内的代码
    loop Looptop    ; ecx--，若 ecx!=0，跳转到 Looptop
    ```
  - **注**：用 `loop` 指令，只能用 ecx 作为循环计数器

### 4.3.4 函数调用的机器级表示

#### 4.3.4.1 Call 和 ret 指令
- **函数的栈帧**：保存函数大括号内定义的局部变量、保存函数调用相关的信息
- **函数调用指令**：`call 函数名` - 通常用函数名作为函数起始地址的标号
  - 示例：`call add`
- **函数返回指令**：`ret`
- **call 指令的作用**：
  1. 将 IP 旧值压栈保存（保存栈帧顶部）
  2. 设置 IP 新值，无条件转移至被调用函数的第一条指令
- **ret 指令的作用**：从函数的栈帧顶部找到 IP 旧值，将其出栈并恢复 IP 寄存器
- ![如何访问栈帧](https://youke1.picui.cn/s1/2025/08/06/4.3.4_2_如何访问栈帧(函数调用的机器级表示)PT1M49.792S.webp)

#### 4.3.4.2 如何访问栈帧
- **标记栈帧范围**：
  - **EBP**：指向当前栈帧的“底部”
  - **ESP**：指向当前栈帧的“顶部”
- **注**：高地址是栈底，低地址是栈顶。CPU 内部只有一个 EBP 和 ESP
- **访问栈帧数据**：
  - **push 和 pop 指令**：
    - `push x` - 先让 esp 减 4，再将 x 压入（x 可以是立即数、寄存器、主存地址）
    - `pop y` - 栈顶元素出栈写进 y，再让 esp 加 4（y 可以是寄存器、主存地址）
    - 示例：
      - `pop eax` - 栈顶元素出栈，写入寄存器 eax
      - `pop [ebp+8]` - 栈顶元素出栈，写入主存地址 [ebp+8]
  - **mov 指令**：
    - 示例：
      ```
      sub esp, 12        ; 栈顶指针-12
      mov [esp+8], eax   ; 将 eax 的值复制到主存 [esp+8]
      mov [esp+4], 985   ; 将 985 复制到主存 [esp+4]
      mov [esp], eax     ; 将 eax 的值复制到主存 [esp]
      add esp, 8         ; 栈顶指针+8
      ```
    - **注**：可以用 mov 指令，结合 esp、ebp 指针访问栈帧数据；可以用减法/加法指令（如 sub/add）修改栈顶指针 esp 的值；mov 指令结合 esp、ebp 可以访问栈帧里的任意数据

#### 4.3.4.3 如何切换栈帧
- **函数调用时如何切换栈帧**：
  - `push ebp` - 保存上一层函数的栈帧基址（ebp 旧值）
  - `mov ebp, esp` - 设置当前函数的栈帧基址（ebp 新值）
  - **注**：以上两步等价于 `enter` 指令
  - `mov esp, ebp` - 让 esp 指向当前栈帧的底部
  - `pop ebp` - 将 esp 所指元素出栈，写入寄存器 ebp
  - **注**：以上两步等价于 `leave` 指令，每个函数 ret 前的例行处理
- **栈帧底部**：是上一层函数的栈帧基址
- **ret 指令的作用**：从函数的栈帧顶部找到 IP 旧值，将其出栈并恢复 IP 寄存器
- **注**：执行完 leave 指令，栈帧顶部是 IP 旧址

#### 4.3.4.4 如何传递参数和返回值
- **一个栈帧可能包含的内容**：
  - 栈帧最底部一定是上一次栈帧基址（ebp 旧值）
  - 栈帧最顶部一定是返回地址（当前函数的栈帧除外）
  - 局部变量：C 语言中越靠前定义的局部变量越靠近栈顶
  - 调用参数：参数列表中越靠前的参数越靠近栈顶
  - **注**：通常将局部变量集中存储在栈帧底部区域；通常将调用参数集中存储在栈帧顶部区域
- **栈帧大小**：为 16B 整数倍，因此可能产生未使用区域
- **函数调用时**：call 指令将 IP 寄存器值（返回地址）压栈保存
- **函数返回值**：通常用 eax 寄存器存储函数返回结果
- **注**：mov 指令不允许两个操作数同时来自主存
- ![4.3.4_4_如何传递参数和返回值(函数调用的机器级表示)PT18M3.841S - 副本.webp](https://youke1.picui.cn/s1/2025/08/06/6893707c32736.webp)

## 4.4 CISC 和 RISC
- 不同的指令系统
![4.4_CISC和RISCPT12M3.08S - 副本.webp](https://youke1.picui.cn/s1/2025/08/06/6893707c25f98.webp)