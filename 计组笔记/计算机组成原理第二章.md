# 计算机组成原理 - 第二章


## 2.1.1 加法器

一位全加器分为 **Ci-1**（低位进位）和 **Ci**（向高位进位），**Ai** 和 **Bi**，以及 **Si**（本位和）。

![](https://youke1.picui.cn/s1/2025/08/06/6893304377a04.webp)

![2.2.1_1 加法器PT6M41.517S.webp](https://youke1.picui.cn/s1/2025/08/06/6893304346319.webp)

把 n 个一位全加器串接起来，就可进行两个 n bit 数的相加。

![2.2.1_1 加法器PT8M53.095S.webp](https://youke1.picui.cn/s1/2025/08/06/68933043c8ef9.webp)

**不足之处**：进位信息是串位进行产生的，计算速度取决于进位产生和传递速度。位数越多，运算速度越慢。
- **注1**：电信号到达稳态需要一定时间，因此进位产生速度会有延迟。
- **注2**：串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成。由于两个输入端允许并行输入 n bit，因此这种加法器属于**并行加法器**；由于进位信息是串行产生得到，因此从“进位方式”看，这种加法器属于**串行进位加法器**。综上，很多教材把这种加法器称为“串行进位的并行加法器”。

![2.2.1_1 加法器PT10M23.883S.webp](https://youke1.picui.cn/s1/2025/08/06/68933044050c3.webp)

**并行进位的并行加法器**：所有进位信息都是同时产生的，几乎没有延迟。

![2.2.1_1 加法器PT14M45.77S.webp](https://youke1.picui.cn/s1/2025/08/06/68933043ec639.webp)

### 带标志位的加法器
- **OF 溢出标志**：用于判断带符号数加减运算是否溢出，**OF=1** 表示溢出；**OF=0** 表示未溢出。
- **SF 符号标志**：用于判断带符号数加减运算结果的正负性，**SF=1** 表示结果为负；**SF=0** 表示结果为正。
- **ZF 零标志**：用于判断加减运算结果是否为0，**ZF=1** 表示结果为0；**ZF=0** 表示结果不为0。
- **CF 进位/借位标志**：用于判断无符号数加减运算是否溢出，**CF=1** 表示溢出；**CF=0** 表示未溢出。

![2.2.1_1 加法器PT19M34.589S.webp](https://youke1.picui.cn/s1/2025/08/06/68933047d5174.webp)

**标志位计算**：
- **OF = Cn ⊕ Cn-1**：即最高位的进位异或次高位的进位，反映带符号数加减运算是否溢出。
- **SF = Sn**：也就是取运算结果的最高位（符号位），反映带符号数加减运算的正负性。
- **ZF = Sn+...+S2+S1**：仅当运算结果所有 bit 全 0 时，ZF 才为 1，此时表示运算结果为 0。
- **CF = Cout ⊕ Cin**：反映无符号数加减运算是否溢出。

---

## 2.1.3 算术逻辑单元（ALU）

### 算术逻辑单元的作用
- **CPU** 由**控制器**和**运算器**组成。
- **控制器**负责解析指令，并根据指令功能发出相应的控制信号。
- **运算器**负责对数据进行处理，如加减乘除等。
- **ALU**是一种组合逻辑电路，实现了加减乘除、与或非等功能。因此，**ALU**是运算器的核心。
- 由于加减乘除等运算都要基于“加法”来实现，因此**加法器**是 ALU 的核心。

![2.2.1_3 算数逻辑单元ALUPT5M3.877S.webp](https://youke1.picui.cn/s1/2025/08/06/6893304829233.webp)

- **ALU 控制信号**：如果 ALU 支持 k 种功能，则控制信号位数 **m ≥ log₂ K**（log₂ K 向下取整）。

![2.2.1_3 算数逻辑单元ALUPT11M54.456S.webp](https://youke1.picui.cn/s1/2025/08/06/68933227bad48.webp)

- **ALU 的运算数、运算结果位数**与计算机的**机器字长**相同。
- **ZF/OF/SF/CF 标志位**的信息会被送入到 **PSW 程序状态字寄存器**。

---

## 2.2.2 定点数的加减运算

### 逻辑移位（常用于处理无符号整数）
- **逻辑左移**：高位移出丢弃，低位补 0。
  - 注意：若逻辑左移丢弃的位=1，则发生溢出。
- **逻辑右移**：低位移出丢弃，高位补 0。
  - 对于无符号整数，每逻辑右移一位，相当于 $÷2$。
  - 注意：若逻辑右移的位=1，则会丢失精度。

### 算术移位（常用于处理带符号整数）
- 在现代计算机中，带符号整数都是用**补码**表示的。
- **算术左移**：高位移出丢弃，低位补 0。
  - 注意：若算术左移前后的符号位不同，则发生溢出。即符号位与最新的丢弃的位不同则发生溢出。
- **算术右移**：低位移出丢弃，高位补原先符号位，即 1 补 1，0 补 0。

![2.2.2 定点数的移位运算PT12M56.782S.webp](https://youke1.picui.cn/s1/2025/08/06/6893327be547d.webp)

---

## 2.2.3.1 定点数的加减运算

![2.2.2 定点数的移位运算PT12M56.782S.webp](https://youke1.picui.cn/s1/2025/08/06/6893327be547d.webp)

- 机器字长为 8 位，含一位符号位，即带符号数。
- B 是负数，$[-B]_{\text{补}}$= $[B]_{\text{补}}$ 连同符号位一起取反加 1。
- 示例：
  - **-2**：
    - 原码：1,000 0010
    - 反码：1,111 1101
    - 补码：1,111 1110
  - **2**：
    - 补码：0,000 0010
- 负数的补码连同符号位取反再加一就是正数的补码。

### 定点数的加减运算的溢出判断
- 设机器字长为 8 位（含一位符号位）：
  - 只有“正数+正数”才会发生**上溢**（正+正=负）。
  - 只有“负数+负数”才会发生**下溢**（负+负=正）。

### 溢出判断的三种方法
- **采用一位符号位**：
  - 设 A 的符号位为 $A_{\text{s}}$，B 的符号位为 **$B_{\text{s}}$**，运算结果的符号位为 **$S_{\text{s}}$**，则溢出逻辑表达式为 **V=$A_{\text{s}}$$B_{\text{s}}$$\overline{S_{\text{s}}}$+$\overline{A_{\text{s}}}$$\overline{B_{\text{s}}}$$S_{\text{s}}$**。
  - 若 **V=0**，表示无溢出。
  - 若 **V=1**，表示溢出。
  - 这句就是上述溢出判断的符号化表示。
- 其余方法了解即可。

---

## 2.2.3.3 补码加减运算电路

![2.2.3_3 补码加减运算电路PT6M23.032S.webp](https://youke1.picui.cn/s1/2025/08/06/6893327bb99b1.webp)

- **多路选择器 MUX 的加减法控制电路**：
  - 加法：0
  - 减法：1
- 当是加法时，按位相加即可；当是减法时，将减数 **Y** 全部按位取反，末位+1，得到 **$[-Y]_{\text{补}}$**，减法变加法。

### 无符号数加法/减法的溢出判断
- **手算判断溢出的方法**：n bit 无符号整数表示范围 0~$2^n-1$，超出此范围则溢出。
- **计算机判断溢出的方法**：
  - 无符号数加法的溢出判断：最高位产生的进位=1 时，发生溢出，否则未溢出。
  - 无符号数减法的溢出判断：减法变加法，最高位产生的进位=0 时，发生溢出，否则未溢出。

---

## 2.2.4.0 乘法除法运算复习说明

### 无符号整数乘法原理
以 4 bit 无符号整数为例：

![2.2.4_1 无符号整数的乘法运算原理PT24M57.412S.webp](https://youke1.picui.cn/s1/2025/08/06/6893327bf2b8c.webp)

#### 二进制乘法：1101 × 1011

| 步骤         | 计算过程              | 部分积结果       |
|--------------|-----------------------|------------------|
| 初始值       | `0000`                | \( P_0 = 0000 \) |
| 第1步 (+1101) | `0000 + 1101`          | \( P_1 = 1101 \) |
| 第2步 (+1101) | `1101 + 1101`          | \( P_2 = 100111 \) |
| 第3步 (+0000) | `100111 + 0000`        | \( P_3 = 100111 \) |
| 第4步 (+1101) | `100111 + 1101`        | \( P_4 = 10001111 \) |

**最终乘积**：\( 1101 \times 1011 = 10001111 \)

---

## 2.2.4.1 无符号整数的乘法运算原理

- 乘积寄存器一开始放 0000，乘数寄存器 **Y** 放 1011，被乘数寄存器 **X** 放 1101，通过 **ALU**，寄存器 **P** 和 **Y** 和进位 **C** 右移的同时 **Cn** 减 1。移出的位与被乘数相乘再与乘积寄存器 **P** 的相加再放回 **P** 中。
- 结束（计数器 **Cn=0**）：
  1. 乘法运算的结果用 2n 位暂存（寄存器 **P**、寄存器 **Y**）。
  2. 在很多计算机架构中，通常仅保留低 n 位作为乘积结果（因此，运算结果可能发生溢出）。

### 无符号整数乘法的溢出判断与原理
- **无符号整数乘法的溢出判断**：两个 n bit 无符号整数相乘，运算结果用 2n bit 暂存。通常仅保留低 n 位作为乘法运算结果。若高位不全为零，说明发生溢出，此时可将 **OF 标志位**（溢出标志位）置为 1。

### 溢出的处理
1. 忽略，会导致错误。
2. 处理“溢出”这种“异常”，可以在乘法指令之后执行一条溢出自陷指令，该指令会检查 **OF 标志位**，若 **OF=1**，就执行操作系统的“异常处理系统”。

### 无符号数乘法运算电路的结构
- **ALU** 是核心。
- **C** 保存本轮加法产生的进位。
- 用 2n bit 暂存乘法结果，最终仅保留低 n bit。若高 n bit 不全为 0，说明发生溢出。
- 控制信号，控制寄存器 **P** 允许被写入。
- 根据 **Y** 的最低位发出控制信号。
- 计数器 **Cn** 保存剩余循环次数。
- 控制信号，控制让 **ALU** 执行加法运算。

---

## 2.2.4.2 带符号整数的乘法运算原理

重复 n 轮加减法、移位运算，直到计数器 **Cn=0**：
1. 将乘数寄存器 **Y** 的最低位、辅助位，2 bit 送入“控制逻辑”进行判断。
2. 根据寄存器 **Y** 的最低位，辅助位，决定是“+[X]补”、“-[X]补”、“+0”。
3. 将【**P**，**Y**，辅助位】视为整体，算术右移一位。
4. 计数器 **Cn** 减 1。

**记忆技巧**：
- 辅助位 - Y 最低位 = 1 ---- P + [X]补
- 辅助位 - Y 最低位 = 0 ---- P + 0
- 辅助位 - Y 最低位 = -1 --- P - [X]补

### 带符号整数乘法原理：溢出判断与处理
- 两个 n bit 带符号整数相乘，运算结果用 2n bit 暂存。通常仅保留低 n 位作为乘法运算结果。若高 n+1 位不完全相同，说明发生溢出，此时可将 **OF 标志位** 置为 1。
- 溢出处理同无符号整数乘法电路处理过程。

### 计算机实现乘法运算的三种方式
1. 由逻辑运算、加减运算等效实现乘法，但是运算速度很慢。
2. 由 **ALU**、移位器、寄存器、控制逻辑组成的乘法电路，所需时钟数由 n bit 无符号数决定。
3. 阵列乘法器，在一个时钟完成。

---

## 2.2.4.4 无符号整数的除法运算原理

- 若被除数不足 2n bit，需要将被除数拓展为 2n bit，统一为 2n bit / n bit。
- 最终得到 n bit 商、n bit 余数。

### 开始
1. 将数据放入寄存器，除数放入寄存器 **Y**。
2. 被除数放入寄存器【**R**，**Q**】并完成零扩展。
3. 计数器 **Cn** 的初始值置为 n。

### 特殊情况检查
1. 如果“除数为 0 异常”，停止除法运算，调用操作系统的异常处理程序。
2. 如果被除数 < 除数，则商=0，余数=被除数，除法器不必再执行。

![2.2.4_4 无符号整数的除法运算原理PT11M23.934S.webp](https://youke1.picui.cn/s1/2025/08/06/689332fe9b063.webp)

### 进行 1+n 轮处理（计算 1+n 位商）
1. **上商的规则**：如果【**R**】-【**Y**】>=0，则上商 1，否则上商 0。
2. **第一轮特殊处理（商溢出判断）**：直接上商，若第一位商=1，发生“商溢出”异常，停止除法运算；若第一位商=0，说明不会发生“商溢出”，不必保存这位商，也不让 **Cn--**，除法运算继续。
3. **其余 n 轮处理**：
   1. 先左移，空出的位用于上商。
   2. 上商，背后的过程可能会涉及进行加法\减法。
   3. 计数器 **Cn--**，当计数器 **Cn=0** 时，除法运算结束。

### 与无符号乘法的不同点
1. 乘法电路的 **C**，**P**，**Y** 寄存器右移，除法电路的 **R**，**Q** 左移。
2. 乘法电路的被乘数 **X** 在上面，乘数 **Y** 在下面，除法电路的是除数 **Y** 在上面，被除数的位置在 **Q** 寄存器。

### 除法运算电路的结构
- **ALU** 是核心。
- **R** 寄存器最终保存 n bit 余数。
- 开始运算前，需要用【**R**，**Q**】2n bit 存放被除数，若被除数不足 2n bit，需要进行位拓展。
- **Q** 最终保存 n bit 商。
- 控制【**R**，**Q**】左移。

![2.2.4_4 无符号整数的除法运算原理PT32M42.377S.webp](https://youke1.picui.cn/s1/2025/08/06/689332fed71fd.webp)

### 关于商溢出的进一步探讨
- **双精度除法**：即 2n bit / n bit，商的实际位数有可能超过 n bit，因此，无符号整数的双精度除法可能发生“商溢出”。
- **单精度除法**：不会发生商溢出。单精度除法需要统一为 2n bit / n bit。
- 示例：
  - 255/15=17 商溢出了，超过了 4 bit 的范围。
    - 1111 1111 / 1111 = 1 0001
  - 15/1=15 单精度商不可能溢出。
    - 0000 1111 / 0001 = 1111

---

## 2.3.1.1 浮点数的表示

### 从科学计数法理解浮点数
- 浮点数由**符号**、**尾数**和**阶码**组成。
- **规格化**：确保尾数的最高位非 0 数位刚好在小数点之前。

### float 单精度浮点型的存储
- 结构：**符号**（1 bit）、**阶码**（8 bit）、**尾数**（23 bit）。
- **符号的存储**：0 表示正，1 表示负。
- **尾数的存储**：规定小数点位置在 23 bit 之前，默认存储规格化尾数，小数点前的 1 省略（隐含）。
- **阶码的存储**：用移码表示，规定偏置值为 127（即 2^7 - 1）。

#### 如何将十进制真值转换为偏置值为 M 的移码
1. 将十进制真值 + 偏置值。
2. 按“无符号整数”规则转换为指定位数。

### 双精度浮点型的存储
- 结构：**符号**（1 bit）、**阶码**（11 bit）、**尾数**（52 bit）。
- 偏置值为 1023（即 2^10 - 1）。

---

## 2.3.1.2 浮点数的表示例题训练

### 复杂小数如何转换为二进制
- **乘基取整法**（仅用于处理十进制真值的小数部分）：
  - 乘基（基数为 2），取整。
  - 出现了进位：取 1，取小数点后的继续乘。
  - 没出现进位：取 0。
  - 直到小数点后为 0。

---

## 2.3.1.3 浮点数的表示范围及特殊状态

### IEEE 754 标准规定
1. 仅当阶码不全为 0、也不全为 1 时，表示这是一个“规格化浮点数”。
2. 阶码全为 0、全为 1 留作特殊用途，需要按照特殊的方式去解读真值。

### 特殊状态的浮点数

| 值的类型     | 单精度 float (32位) | 双精度 double (64位) |      |                     |     |     |                |                      |
| -------- | --------------- | ---------------- | ---- | ------------------- | --- | --- | -------------- | -------------------- |
|          | 符号              | 阶码               | 尾数   | 值                   | 符号  | 阶码  | 尾数             | 值                    |
| 正零       | 0               | 全0               | 全0   | +0                  | 0   | 全0  | 全0             | +0                   |
| 负零       | 1               | 全0               | 全0   | -0                  | 1   | 全0  | 全0             | -0                   |
| 非规格化正数   | 0               | 全0               | f!=0 | \( 2^{-126}(0.f) \) | 0   | 全0  | \( f \neq 0 \) | \( 2^{-1022}(0.f) \) |
| 非规格化负数   | 1               | 全0               | f!=0 | \(-2^{-126}(0.f) \) | 1   | 全0  | \( f \neq 0 \) | \(-2^{-1022}(0.f) \) |
| 正无穷大     | 0               | 全1               | 全0   | +∞                  | 0   | 全1  | 全0             | +∞                   |
| 负无穷大     | 1               | 全1               | 全0   | -∞                  | 1   | 全1  | 全0             | -∞                   |
| 无定义数（非数） | 0或1             | 全1               | f!=0 | NaN                 | 0或1 | 全1  | \( f \neq 0 \) | NaN                  |

### 规格化浮点数的表示范围
- 规格化浮点数的阶码不全为 0，也不全为 1。
- **移码转真值**：先按“无符号整数”解读阶码二进制串，再减掉偏置值，得到真值。
- 先按无符号数解读阶码 **e**，则取值范围为 1~254，减掉偏置值 127，阶码范围为 -126~127。

#### 规格化浮点数的表示范围
![2.3.1_3 浮点数的表示范围、几种特殊状态（上）PT13M14.715S.webp](https://youke1.picui.cn/s1/2025/08/06/689332feaa098.webp)

##### 取值范围总结（十进制）
- **负数范围**：`-(2 - 2^-23) × 2^127` 到 `-1.0 × 2^-126`
- **正数范围**：`+1.0 × 2^-126` 到 `+(2 - 2^-23) × 2^127`

### 浮点数的上溢
- 运算结果大于最大规格化正数时称为**正上溢**，小于绝对值最大的规格化负数称为**负上溢**，正上溢和负上溢统称为**上溢**。

#### 浮点数上溢的处理
1. 浮点数运算部件将运算结果设为设置为正无穷或负无穷。
2. 设置浮点数溢出异常标志位，例如 x86 会将浮点运算单元 **FPU** 的 **OE** 设为 1。
   - 注：**IEEE 754** 规定，默认不响应浮点数溢出异常，不中断程序，除非程序员手动开启此类异常响应。

---

## 2.3.1.4 浮点数的下溢

1. 若结果落入非规格化区间 -> 用非规格化浮点数存储；若结果太小（真值逼近于 0）-> 按机器 0 存储。
2. 若下溢置机器 0，设置浮点数下溢异常标志位，例如 x86 会将浮点运算单元 **FPU** 的 **UE** 设为 1。
   - 注：**IEEE 754** 规定，默认不响应浮点数溢出异常，不中断程序，除非程序员手动开启此类异常响应。

---


