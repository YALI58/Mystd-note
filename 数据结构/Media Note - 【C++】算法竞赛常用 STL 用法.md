---
media: https://www.bilibili.com/video/BV1L8411y7th/
---
# 算法竞赛常用 STL 用法

---
https://chat.deepseek.com/
## 1. Vector

  - **构造方法**
    - `vector<类型> arr(长度, [初值])`
    - 时间复杂度：O(n)
    - 示例：
      - `vector<int> arr;`  // 空int数组
      - `vector<int> arr(100);`  // 长100的int数组
      - `vector<int> arr(100,1);`  // 长100，值全为1的int数组
      - `vector<vector<int>> mat(100, vector<int>(0))`  // 100行0列二维数组
      - `vector<vector<int>> mat(100, vector<int>(666, -1))`  // 100行666列，值全为-1
  - **常用操作**
    - 尾接：`push_back(元素)` - 尾部添加，长度+1
    - 尾删：`pop_back()` - 尾部删除，长度-1
    - 重设长度：`resize(长度, [初值])` - 调整长度
  - **适用场景**
    - 一般情况下，`vector` 可以替换普通数组，除非该题对常数优化要求极高。
    - 有些情况普通数组无法解决：n*m的矩阵，1<= n,m<=10**6 且n*m<=10**6
      - 如果用普通数组 `int mat[10000010][1000010]`, 浪费内存，导致MLE。
      - 如果使用 `vector<vector<int>> mat(n+10,vector<int>(m+10))`, 完美解决问题。
      - 另外，`vector` 的数据储存在堆空间，不会爆栈。
    - **大数据量动态增长**：当数据量不确定且可能动态增长时，`vector` 可以自动扩展，避免手动管理内存。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 尾部插入 (`push_back`) | O(1) 均摊       | O(1)       |
    | 尾部删除 (`pop_back`)  | O(1)            | O(1)       |
    | 中间插入/删除    | O(n)            | O(1)       |
    | 随机访问         | O(1)            | O(1)       |
    | 重设长度 (`resize`) | O(n)            | O(n)       |
  - **应用案例**
    - **动态矩阵问题**：在处理不定大小的矩阵时，使用 `vector` 可以动态分配空间，避免内存浪费。
      - 示例代码：
        ```cpp
        int n, m;
        cin >> n >> m;
        vector<vector<int>> mat(n, vector<int>(m, 0));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                cin >> mat[i][j];
            }
        }
        ```
  - **注意事项**
    - **提前指定长度**：如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 `push_back()`。因为 `vector` 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。
    - **当心 `size_t` 溢出**：`vector` 获取长度的方法 `.size()` 返回值类型为 `size_t`，通常OJ平台使用的是32位编译器，那么该类型范围为 `[0,2**32)`。
      - 示例：
        - `vector<int> a(65536);`
        - `long long l=a.size()*a.size();`  // 直接溢出变成0。由于 `65536*65536 = 2**32` 会发生溢出现象。与左边的 `long long` 无关。右边的乘法出现了溢出。
    - **使用 `reserve()` 预分配空间**：如果预知大致的数据量，使用 `arr.reserve(n)` 预分配空间可以避免多次重分配，提高性能。
    - **避免频繁插入和删除中间元素**：`vector` 在中间位置插入和删除元素会导致后续元素移动，时间复杂度为 O(n)，效率较低。
    - **内存释放问题**：调用 `clear()` 不会释放内存，若需释放内存可使用 `shrink_to_fit()` 或重新构造一个新 `vector`。

---

## 2. Stack

  - **构造方法**
    - `stack<类型> stk;`
  - **常用操作**
    - 进栈：`stk.push(元素);`
    - 出栈：`stk.pop();`
    - 取栈顶：`stk.top();` 如 `int a = stk.top();`
    - 大小/清空/判空：`stk.size();`, `stk.empty();`
  - **适用场景**
    - 如果不卡常的话，就可以直接用它而不需要手写栈了。
    - 另外，`vector` 也可以当栈用，`vector` 的 `.back()` 取尾部元素就相当于取栈顶，`.push_back()` 就相当于进栈。
    - **递归替代**：在需要模拟递归过程或处理后进先出的场景（如DFS）时，`stack` 可以用来手动管理调用栈。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 进栈 (`push`)   | O(1)            | O(1)       |
    | 出栈 (`pop`)    | O(1)            | O(1)       |
    | 取栈顶 (`top`)  | O(1)            | O(1)       |
  - **应用案例**
    - **表达式求值**：在处理中缀表达式转后缀表达式或计算表达式结果时，使用 `stack` 管理操作符。
      - 示例代码：
        ```cpp
        stack<char> stk;
        string expr;
        cin >> expr;
        for(char c : expr) {
            if(c == '(') stk.push(c);
            else if(c == ')') {
                while(!stk.empty() && stk.top() != '(') {
                    cout << stk.top();
                    stk.pop();
                }
                stk.pop(); // 弹出 '('
            }
            // 其他逻辑...
        }
        ```
  - **注意事项**
    - **不可访问内部元素**！以下都是错误用法：
      - `for(int i=0;i<stk.size();i++) cout<<stk[i]<<endl;`
      - `for(auto ele : stk) cout<<ele<<endl;`
    - **判空检查**：在调用 `top()` 或 `pop()` 前必须检查栈是否为空，否则可能导致未定义行为。
      - 示例：
        - `if(!stk.empty()) int a = stk.top();`
    - **性能考虑**：`stack` 底层通常基于 `deque` 或 `vector`，如果对性能要求极高，可以考虑手写数组实现的栈。

---

## 3. Queue

  - **构造方法**
    - `queue<int> que;`
  - **常用操作**
    - 进队：`que.push(元素);`
    - 出队：`que.pop();`
    - 取队首：`que.front();` 如 `int a = que.front();`
    - 取队尾：`que.back();` 如 `int a = que.back();`
  - **适用场景**
    - 如果对常数优化要求不高，可以直接使用。
    - **层次遍历**：在需要按层次或顺序处理数据时（如树的层次遍历），`queue` 是理想选择。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 进队 (`push`)   | O(1)            | O(1)       |
    | 出队 (`pop`)    | O(1)            | O(1)       |
    | 取队首 (`front`)| O(1)            | O(1)       |
    | 取队尾 (`back`) | O(1)            | O(1)       |
  - **应用案例**
    - **广度优先搜索（BFS）**：在图的广度优先搜索中，使用 `queue` 管理待访问的节点。
      - 示例代码：
        ```cpp
        queue<int> que;
        vector<bool> visited(n, false);
        que.push(start);
        visited[start] = true;
        while(!que.empty()) {
            int curr = que.front();
            que.pop();
            // 处理当前节点
            for(int next : graph[curr]) {
                if(!visited[next]) {
                    que.push(next);
                    visited[next] = true;
                }
            }
        }
        ```
  - **注意事项**
    - 不可访问内部元素！以下都是错误用法：
      - `for(int i=0;i<que.size();i++) cout<<que[i]<<endl;`
      - `for(auto ele : que) cout<<ele<<endl;`
    - **判空检查**：在调用 `front()` 或 `pop()` 前必须检查队列是否为空，否则可能导致未定义行为。
      - 示例：
        - `if(!que.empty()) int a = que.front();`
    - **性能考虑**：`queue` 底层通常基于 `deque`，如果对性能要求极高，可以考虑手写数组实现的循环队列。

---

## 4. Priority Queue (`priority_queue`)

  - **描述**
    - 提供常数时间最大元素查找，对数时间插入与提取，基于二叉堆。
  - **构造方法**
    - `priority_queue<类型, 容器, 比较器> pque;`
      - 类型：数据类型
      - 容器：底层容器，默认 `vector<类型>`
      - 比较器：大小比较，默认 `less<类型>`，可自定义
      - 示例：
        - `priority_queue<int> pque1;` // 大顶堆
        - `priority_queue<int, vector<int>, greater<int>> pque2;` // 小顶堆
  - **常用操作**
    - 进堆：`.push(元素)` 如 `pque.push(1);`
    - 出堆：`.pop()` 如 `pque.pop();`
    - 取堆顶：`.top()` 如 `int a = pque.top();`
    - 复杂度：进出堆 O(log n)，取堆顶 O(1)
  - **适用场景**
    - 持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 n，插入操作数量 k。
      - 每次插入后进行快速排序：K*n*log n，k大于10**6，可能会超时
      - 使用优先队列维护：K*log n
    - **动态中位数**：在数据流中动态维护中位数时，可以使用两个优先队列（一个大顶堆，一个小顶堆）来实现。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 进堆 (`push`)   | O(log n)        | O(1)       |
    | 出堆 (`pop`)    | O(log n)        | O(1)       |
    | 取堆顶 (`top`)  | O(1)            | O(1)       |
  - **应用案例**
    - **Top-K 问题**：从大量数据中找出前 K 个最大或最小的元素，使用优先队列维护一个大小为 K 的堆。
      - 示例代码：
        ```cpp
        priority_queue<int, vector<int>, greater<int>> minHeap;
        vector<int> data; // 假设数据已输入
        int k;
        cin >> k;
        for(int num : data) {
            minHeap.push(num);
            if(minHeap.size() > k) minHeap.pop();
        }
        // minHeap 中即为前 K 个最小元素
        ```
  - **注意事项**
    - 仅堆顶可读，只访问堆顶，其他元素都无法读取到。以下是错误用法：
      - `cout<<pque[1]<<endl;`
    - 所有元素不可写：堆中所有元素都是不可修改的。以下是错误用法：
      - `pque[1] = 2;`
      - `pque.top() = 1;`
    - 如果你想修改堆顶，那你要先弹出再添加。
    - **判空检查**：在调用 `top()` 或 `pop()` 前必须检查优先队列是否为空，否则可能导致未定义行为。
      - 示例：
        - `if(!pque.empty()) int a = pque.top();`
    - **自定义比较器注意**：自定义比较器时需确保严格弱序，否则可能导致未定义行为。
    - **性能优化**：如果需要频繁修改非堆顶元素，优先队列不是最佳选择，可考虑其他数据结构如 `set`。

---

## 5. Set (`set`)

  - **描述**
    - 提供对数时间插入、删除、查找的集合，基于红黑树，元素自动排序且唯一。
  - **构造方法**
    - `set<类型> s;`
    - 示例：
      - `set<int> s;` // 整数集合
  - **常用操作**
    - 插入：`s.insert(元素);` 如 `s.insert(5);`
    - 删除：`s.erase(元素);` 或 `s.erase(迭代器);` 如 `s.erase(5);`
    - 查找：`s.find(元素);` 返回迭代器，不存在返回 `s.end()`
    - 计数：`s.count(元素);` 返回出现次数（0或1）
    - 大小：`s.size();` 元素个数
    - 清空：`s.clear();` 清空集合
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = s.begin(); it != s.end(); ++it) cout << *it << endl;`
        - `for(auto ele : s) cout << ele << endl;`
  - **复杂度**
    - 插入、删除、查找：O(log n)
  - **适用场景**
    - 需要自动排序和去重的场景，例如统计不同元素的个数。
    - 需要快速查找、插入和删除操作的场景。
    - 元素是否出现过。元素大小[-10**18,10**18]，元素数量10*6，vls数组无法实现，通过set可以实现。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 插入 (`insert`) | O(log n)        | O(1)       |
    | 删除 (`erase`)  | O(log n)        | O(1)       |
    | 查找 (`find`)   | O(log n)        | O(1)       |
  - **应用案例**
    - **去重统计**：在处理需要统计不同元素个数的问题时，使用 `set` 自动去重。
      - 示例代码：
        ```cpp
        set<int> s;
        int n;
        cin >> n;
        for(int i = 0; i < n; i++) {
            int x;
            cin >> x;
            s.insert(x);
        }
        cout << s.size() << endl; // 输出不同元素的个数
        ```
  - **注意事项**
    - 元素不可修改，只能插入和删除。如果需要修改元素，需先删除再插入。
    - 迭代器使用时注意不要在遍历过程中修改容器结构（插入或删除操作可能会导致迭代器失效）。只能通过迭代器遍历。
    - **有序性依赖**：`set` 元素是有序的，但如果只需要去重而不需要排序，可以考虑使用 `unordered_set` 以换取平均 O(1) 的操作时间。
    - **内存开销**：`set` 由于红黑树实现，内存开销比数组或 `vector` 大，需注意内存限制。

---

## 6. Map (`map`)

  - **描述**
    - 提供对数时间键值对插入、删除、查找，基于红黑树，键自动排序且唯一。
  - **构造方法**
    - `map<键类型, 值类型> m;`
    - 示例：
      - `map<string, int> m;` // 字符串到整数映射
  - **常用操作**
    - 插入：`m.insert(make_pair(键, 值));` 或 `m[键] = 值;` 如 `m["key"] = 10;`
    - 删除：`m.erase(键);` 或 `m.erase(迭代器);` 如 `m.erase("key");`
    - 查找：`m.find(键);` 返回迭代器，不存在返回 `m.end()`
    - 计数：`m.count(键);` 返回键出现次数（0或1）
    - 大小：`m.size();` 键值对个数
    - 清空：`m.clear();` 清空映射
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = m.begin(); it != m.end(); ++it) cout << it->first << ": " << it->second << endl;`
        - `for(auto& pair : m) cout << pair.first << ": " << pair.second << endl;`
  - **复杂度**
    - 插入、删除、查找：O(log n)
  - **适用场景**
    - 需要键值对存储和快速查找的场景，例如字典或计数器。
    - 需要按键自动排序的场景。
    - **稀疏数据存储**：当数据是稀疏的（如只有少量键有值），`map` 比数组更节省空间，且查找效率高。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 插入 (`insert`) | O(log n)        | O(1)       |
    | 删除 (`erase`)  | O(log n)        | O(1)       |
    | 查找 (`find`)   | O(log n)        | O(1)       |
  - **应用案例**
    - **词频统计**：在统计文本中每个单词出现次数的问题中，使用 `map` 记录单词和其频率。
      - 示例代码：
        ```cpp
        map<string, int> freq;
        string word;
        while(cin >> word) {
            freq[word]++;
        }
        for(auto& pair : freq) {
            cout << pair.first << ": " << pair.second << endl;
        }
        ```
  - **注意事项**
    - 使用 `m[键]` 时，如果键不存在，会自动插入一个默认值（对于 `int` 是 0），可能导致意外行为，建议使用 `find()` 检查。
    - 迭代器使用时注意不要在遍历过程中修改容器结构。
    - **有序性依赖**：`map` 键是有序的，但如果只需要键值映射而不需要排序，可以考虑使用 `unordered_map` 以换取平均 O(1) 的操作时间。
    - **内存开销**：`map` 由于红黑树实现，内存开销较大，需注意内存限制。
    - **键的唯一性**：如果需要一个键对应多个值，可以使用 `multimap`。

---

## 7. String (`string`)

### 描述
- `string` 是 C++ 标准库中用于处理字符串的动态数组容器，支持自动内存管理，提供了许多便捷的字符串操作方法。

### 构造方法
- `string s;`
- 示例：
  - `string s;`  // 空字符串
  - `string s("hello");`  // 初始化为 "hello"
  - `string s(5, 'a');`  // 初始化为 "aaaaa"

### 常用操作
- 输入：`cin >> s;`  // 读取字符串（以空格或换行为分隔符）
- 拼接：`s += "world";`  // 在字符串末尾追加
- 访问：`s[索引];` 或 `s.at(索引);`  // 访问特定字符，`at()` 会进行范围检查
- 查找：`s.find(子串或字符);`  // 返回第一次出现的位置，未找到返回 `string::npos`
- 子串：`s.substr(起始位置, 长度);`  // 提取子字符串
- 替换：`s.replace(起始位置, 长度, 新字符串);`  // 替换部分字符串
- 大小：`s.size();` 或 `s.length();`  // 返回字符串长度
- 清空：`s.clear();`  // 清空字符串
- 判空：`s.empty();`  // 检查是否为空字符串

### 适用场景
- **字符串处理**：`string` 适用于需要频繁操作字符串的场景，如文本处理、输入输出等，相比 C 风格字符串更安全和方便。
- **动态字符串**：当字符串长度不确定时，`string` 可以自动调整大小，避免手动内存管理。

### 复杂度总结
| 操作            | 时间复杂度       | 空间复杂度 |
|-----------------|------------------|------------|
| 拼接 (`+=`)     | O(1) 均摊       | O(1)       |
| 查找 (`find`)   | O(n*m)          | O(1)       |
| 子串 (`substr`) | O(n)            | O(n)       |
| 访问 (`[]` 或 `at`) | O(1)         | O(1)       |

### 应用案例
- **字符串拼接与查找**：处理用户输入的字符串并查找特定子串。
  - 示例代码：
    ```cpp
    string s;
    cin >> s;
    s += " world";
    size_t found = s.find("world");
    if(found != string::npos) {
        cout << "找到 'world' 在位置 " << found << endl;
    }
    ```

### 注意事项
- **拼接效率**：使用 `+=` 拼接字符串比使用 `+` 号再赋值效率更高，因为 `+` 会创建临时对象。
- **查找复杂度**：`find()` 的时间复杂度为 O(n*m)，其中 n 和 m 分别是字符串和子串的长度，需注意大数据量下的性能问题。
- **范围检查**：使用 `at()` 访问字符时会进行范围检查，抛出 `out_of_range` 异常，而 `[]` 不会，需根据需求选择。

---

## 8. Pair (`pair`)

### 描述
- `pair` 是 STL 中的一个简单容器，用于存储一对值，两个值可以是不同类型，类似于一个轻量级的结构体。

### 构造方法
- `pair<类型1, 类型2> p;`
- 示例：
  - `pair<int, int> p;`  // 默认构造，值为 (0, 0)
  - `pair<int, string> p(1, "one");`  // 初始化为 (1, "one")
  - `pair<int, int> p = {1, 2};`  // 使用初始化列表
  - `pair<int, int> p = make_pair(1, 2);`  // 使用辅助函数

### 常用操作
- 访问：`p.first;` 和 `p.second;`  // 访问第一个和第二个元素
- 赋值：`p = make_pair(新值1, 新值2);`  // 整体赋值
- 比较：`==`, `!=`, `<`, `>`, `<=`, `>=`  // 按字典序比较，先比较 `first`，再比较 `second`

### 适用场景
- **键值对存储**：当需要临时存储一对相关数据时，`pair` 是一个轻量级的解决方案，常用在 `map` 或作为函数返回值。
- **多值返回**：函数需要返回两个值时，可以使用 `pair` 封装。

### 复杂度总结
| 操作            | 时间复杂度       | 空间复杂度 |
|-----------------|------------------|------------|
| 构造            | O(1)            | O(1)       |
| 访问 (`first`/`second`) | O(1)     | O(1)       |
| 比较            | O(1)            | O(1)       |

### 应用案例
- **函数返回多值**：从函数返回两个相关值。
  - 示例代码：
    ```cpp
    pair<int, int> getCoordinates() {
        return make_pair(1, 2);
    }
    int main() {
        pair<int, int> p = getCoordinates();
        cout << p.first << " " << p.second << endl;  // 输出: 1 2
        return 0;
    }
    ```

### 注意事项
- **轻量级使用**：`pair` 适合简单的键值对存储，若数据结构复杂或需要更多字段，建议使用自定义结构体。
- **类型推导**：C++11 后可以使用 `auto` 简化 `pair` 的声明，如 `auto p = make_pair(1, "one");`。

---


## 9. Deque (`deque`)

  - **描述**
    - 双端队列，两端高效插入删除，基于分段连续存储。
  - **构造方法**
    - `deque<类型> dq;`
    - 示例：
      - `deque<int> dq;` // 整数双端队列
  - **常用操作**
    - 头部插入：`dq.push_front(元素);` 如 `dq.push_front(1);`
    - 尾部插入：`dq.push_back(元素);` 如 `dq.push_back(2);`
    - 头部删除：`dq.pop_front();`
    - 尾部删除：`dq.pop_back();`
    - 取头部：`dq.front();` 如 `int a = dq.front();`
    - 取尾部：`dq.back();` 如 `int b = dq.back();`
    - 大小：`dq.size();` 元素个数
    - 清空：`dq.clear();` 清空队列
    - 遍历：迭代器、范围for循环或索引访问
      - 示例：
        - `for(auto ele : dq) cout << ele << endl;`
        - `for(int i = 0; i < dq.size(); i++) cout << dq[i] << endl;`
  - **复杂度**
    - 两端插入和删除：O(1)
    - 随机访问：O(1)
  - **适用场景**
    - 需要在队列两端进行高效操作的场景，例如滑动窗口问题。
    - 可以作为 `queue` 或 `stack` 的替代品，功能更灵活。
    - **双端操作需求**：在需要频繁在两端添加或删除元素的场景（如某些调度算法），`deque` 表现优异。
  - **复杂度总结**
    | 操作            | 时间复杂度       | 空间复杂度 |
    |-----------------|------------------|------------|
    | 两端插入 (`push_front`/`push_back`) | O(1) | O(1) |
    | 两端删除 (`pop_front`/`pop_back`)  | O(1)  | O(1) |
    | 随机访问         | O(1)            | O(1)       |
    | 中间插入/删除    | O(n)            | O(1)       |
  - **应用案例**
    - **滑动窗口最大值**：在求解数组滑动窗口内的最大值问题时，使用 `deque` 维护一个单调递减队列。
      - 示例代码：
        ```cpp
        deque<int> dq;
        vector<int> nums; // 假设数组已输入
        int k; // 窗口大小
        cin >> k;
        for(int i = 0; i < nums.size(); i++) {
            while(!dq.empty() && nums[dq.back()] <= nums[i]) dq.pop_back();
            dq.push_back(i);
            if(dq.front() == i - k) dq.pop_front();
            if(i >= k - 1) cout << nums[dq.front()] << endl;
        }
        ```
  - **注意事项**
    - 虽然支持随机访问，但中间位置的插入和删除操作效率较低（O(n)）。
    - 内存使用上比 `vector` 略高，因为是分段存储。
    - **随机访问性能**：虽然支持随机访问，但由于分段存储，随机访问的常数开销比 `vector` 大，不适合频繁随机访问的场景。
    - **两端操作限制**：虽然两端操作是 O(1)，但如果数据量非常大，频繁操作可能仍有性能瓶颈，需注意测试。

---

## 10. Unordered Set (`unordered_set`)

  - **描述**
    - 提供平均常数时间插入、删除、查找的集合，基于哈希表，元素无序且唯一。
  - **构造方法**
    - `unordered_set<类型> us;`
    - 示例：
      - `unordered_set<int> us;` // 整数无序集合
  - **常用操作**
    - 插入：`us.insert(元素);` 如 `us.insert(5);`
    - 删除：`us.erase(元素);` 或 `us.erase(迭代器);` 如 `us.erase(5);`
    - 查找：`us.find(元素);` 返回迭代器，不存在返回 `us.end()`
    - 计数：`us.count(元素);` 返回出现次数（0或1）
    - 大小：`us.size();` 元素个数
    - 清空：`us.clear();` 清空集合
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = us.begin(); it != us.end(); ++it) cout << *it << endl;`
        - `for(auto ele : us) cout << ele << endl;`
  - **复杂度**
    - 平均情况：插入、删除、查找 O(1)
    - 最坏情况：O(n)（哈希冲突严重时）
  - **适用场景**
    - 需要快速去重且不关心元素顺序的场景，如快速检查元素是否存在。
    - 元素数量较大时，平均性能优于 `set`。
  - **应用案例**
    - **快速去重**：处理大数据量去重问题时，使用 `unordered_set` 效率更高。
      - 示例代码：
        ```cpp
        unordered_set<int> us;
        int n;
        cin >> n;
        for(int i = 0; i < n; i++) {
            int x;
            cin >> x;
            us.insert(x);
        }
        cout << us.size() << endl; // 输出不同元素个数
        ```
  - **注意事项**
    - 元素无序，无法依赖排序特性。
    - 哈希冲突可能导致性能下降，需注意数据分布。
    - 内存开销比 `set` 可能更大，因哈希表实现。

---

## 11. Unordered Map (`unordered_map`)

  - **描述**
    - 提供平均常数时间键值对插入、删除、查找，基于哈希表，键无序且唯一。
  - **构造方法**
    - `unordered_map<键类型, 值类型> um;`
    - 示例：
      - `unordered_map<string, int> um;` // 字符串到整数无序映射
  - **常用操作**
    - 插入：`um.insert(make_pair(键, 值));` 或 `um[键] = 值;` 如 `um["key"] = 10;`
    - 删除：`um.erase(键);` 或 `um.erase(迭代器);` 如 `um.erase("key");`
    - 查找：`um.find(键);` 返回迭代器，不存在返回 `um.end()`
    - 计数：`um.count(键);` 返回键出现次数（0或1）
    - 大小：`um.size();` 键值对个数
    - 清空：`um.clear();` 清空映射
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = um.begin(); it != um.end(); ++it) cout << it->first << ": " << it->second << endl;`
        - `for(auto& pair : um) cout << pair.first << ": " << pair.second << endl;`
  - **复杂度**
    - 平均情况：插入、删除、查找 O(1)
    - 最坏情况：O(n)（哈希冲突严重时）
  - **适用场景**
    - 需要快速键值对查找且不关心键顺序的场景，如高效计数器。
    - 元素数量较大时，平均性能优于 `map`。
  - **应用案例**
    - **快速计数**：统计元素出现次数时，使用 `unordered_map` 效率更高。
      - 示例代码：
        ```cpp
        unordered_map<string, int> freq;
        string word;
        while(cin >> word) {
            freq[word]++;
        }
        for(auto& pair : freq) {
            cout << pair.first << ": " << pair.second << endl;
        }
        ```
  - **注意事项**
    - 键无序，无法依赖排序特性。
    - 哈希冲突可能导致性能下降，需注意键的分布。
    - 使用 `um[键]` 时，若键不存在会自动插入默认值（如 `int` 为 0），可能导致意外行为，建议用 `find()` 检查。

---

## 12. Multiset (`multiset`)

  - **描述**
    - 提供对数时间插入、删除、查找的集合，基于红黑树，元素有序且可重复。
  - **构造方法**
    - `multiset<类型> ms;`
    - 示例：
      - `multiset<int> ms;` // 整数有序可重复集合
  - **常用操作**
    - 插入：`ms.insert(元素);` 如 `ms.insert(5);`
    - 删除：`ms.erase(元素);` 删除所有该元素，或 `ms.erase(迭代器);` 删除单个，如 `ms.erase(ms.find(5));`
    - 查找：`ms.find(元素);` 返回第一个匹配迭代器，不存在返回 `ms.end()`
    - 计数：`ms.count(元素);` 返回元素出现次数
    - 大小：`ms.size();` 元素个数
    - 清空：`ms.clear();` 清空集合
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = ms.begin(); it != ms.end(); ++it) cout << *it << endl;`
        - `for(auto ele : ms) cout << ele << endl;`
  - **复杂度**
    - 插入、删除、查找：O(log n)
  - **适用场景**
    - 需要维护有序且允许元素重复的场景，如统计元素频率并按序输出。
  - **应用案例**
    - **有序频率统计**：需要统计元素出现次数并按顺序输出的场景。
      - 示例代码：
        ```cpp
        multiset<int> ms;
        int n;
        cin >> n;
        for(int i = 0; i < n; i++) {
            int x;
            cin >> x;
            ms.insert(x);
        }
        for(auto ele : ms) {
            cout << ele << " ";
        }
        ```
  - **注意事项**
    - 元素有序，可重复，适合需要排序的场景。
    - 删除操作需注意，`erase(元素)` 会删除所有匹配元素，若只删一个需用迭代器。
    - 内存开销较大，因红黑树实现。

---

## 13. Multimap (`multimap`)

  - **描述**
    - 提供对数时间键值对插入、删除、查找，基于红黑树，键有序且可重复。
  - **构造方法**
    - `multimap<键类型, 值类型> mm;`
    - 示例：
      - `multimap<string, int> mm;` // 字符串到整数有序可重复映射
  - **常用操作**
    - 插入：`mm.insert(make_pair(键, 值));` 如 `mm.insert(make_pair("key", 10));`
    - 删除：`mm.erase(键);` 删除所有该键，或 `mm.erase(迭代器);` 删除单个，如 `mm.erase(mm.find("key"));`
    - 查找：`mm.find(键);` 返回第一个匹配迭代器，不存在返回 `mm.end()`
    - 计数：`mm.count(键);` 返回键出现次数
    - 大小：`mm.size();` 键值对个数
    - 清空：`mm.clear();` 清空映射
    - 遍历：迭代器或范围for循环
      - 示例：
        - `for(auto it = mm.begin(); it != mm.end(); ++it) cout << it->first << ": " << it->second << endl;`
        - `for(auto& pair : mm) cout << pair.first << ": " << pair.second << endl;`
  - **复杂度**
    - 插入、删除、查找：O(log n)
  - **适用场景**
    - 需要键有序且允许键重复的键值对存储场景，如一个键对应多个值的映射。
  - **应用案例**
    - **多值映射**：一个键对应多个值时，使用 `multimap` 存储。
      - 示例代码：
        ```cpp
        multimap<string, int> mm;
        mm.insert(make_pair("apple", 1));
        mm.insert(make_pair("apple", 2));
        for(auto it = mm.equal_range("apple").first; it != mm.equal_range("apple").second; ++it) {
            cout << it->first << ": " << it->second << endl;
        }
        ```
  - **注意事项**
    - 键有序，可重复，适合需要排序的场景。
    - 删除操作需注意，`erase(键)` 会删除所有匹配键，若只删一个需用迭代器。
    - 无法直接用 `mm[键]` 访问，因键可重复，建议用 `equal_range()` 获取范围。
    - 内存开销较大，因红黑树实现。

---

## 14. STL 容器对比分析

为了帮助选择合适的 STL 容器，以下从不同维度对容器进行对比分析，涵盖性能、特性和适用场景。

### 14.1 有序容器 vs 无序容器

| 特性            | 有序容器 (`set`, `map`, `multiset`, `multimap`) | 无序容器 (`unordered_set`, `unordered_map`) |
|-----------------|-----------------------------------------------|---------------------------------------------|
| **底层实现**    | 红黑树（平衡二叉搜索树）                      | 哈希表                                      |
| **元素顺序**    | 元素自动排序（默认升序，可自定义）            | 元素无序                                    |
| **操作复杂度**  | 插入、删除、查找：O(log n)                   | 平均 O(1)，最坏 O(n)（哈希冲突严重时）     |
| **内存开销**    | 较高，因树结构需要额外节点指针                | 可能较高，因哈希表可能有空桶                |
| **适用场景**    | 需要元素有序、范围查询或排序输出的场景         | 需要快速查找、不关心顺序的场景              |
| **注意事项**    | 性能稳定，但常数较大                         | 哈希冲突可能导致性能下降，需注意数据分布    |

**示例场景**：
- 如果需要统计元素并按顺序输出，使用 `set` 或 `multiset`；如果只关心元素是否存在且数据量大，使用 `unordered_set`。
- 如果需要键值对映射并按键排序，使用 `map` 或 `multimap`；如果只关心快速查找，使用 `unordered_map`。

### 14.2 关联容器 vs 序列容器

| 特性            | 关联容器 (`set`, `map`, `unordered_set`, `unordered_map`, `multiset`, `multimap`) | 序列容器 (`vector`, `deque`, `list`) |
|-----------------|------------------------------------------------------------------|------------------------------|
| **底层实现**    | 红黑树或哈希表                                                  | 数组、双端队列或链表         |
| **访问方式**    | 通过键或值查找，快速定位特定元素                                 | 通过索引或迭代器顺序访问     |
| **操作复杂度**  | 查找：O(log n) 或 O(1)（取决于实现）                            | 查找：O(n)（线性搜索）       |
| **元素特性**    | 元素通常唯一（除 `multiset`, `multimap`），可快速去重            | 元素可重复，顺序由插入决定   |
| **适用场景**    | 需要快速查找、去重或键值映射的场景                               | 需要顺序存储、频繁遍历的场景 |
| **注意事项**    | 不支持随机访问（如索引），内存开销较大                          | 支持随机访问（部分），内存较紧凑 |

**示例场景**：
- 如果需要快速查找特定元素或去重，使用关联容器如 `set` 或 `unordered_set`；如果需要按顺序存储和遍历，使用序列容器如 `vector`。
- 如果需要键值对映射，使用关联容器如 `map` 或 `unordered_map`；如果需要模拟队列或栈，使用序列容器如 `deque`。

### 14.3 唯一容器 vs 多重容器

| 特性            | 唯一容器 (`set`, `map`, `unordered_set`, `unordered_map`) | 多重容器 (`multiset`, `multimap`) |
|-----------------|----------------------------------------------------------|---------------------------|
| **元素特性**    | 元素或键唯一                                             | 元素或键可重复            |
| **操作复杂度**  | 插入、删除、查找：O(log n) 或 O(1)                      | 插入、删除、查找：O(log n) |
| **适用场景**    | 需要去重或键唯一映射的场景                               | 需要统计频率或多值映射的场景 |
| **注意事项**    | 插入重复元素会被忽略                                     | 删除需注意是否删除所有匹配  |

**示例场景**：
- 如果需要统计不同元素个数，使用 `set` 或 `unordered_set`；如果需要统计每个元素出现次数，使用 `multiset`。
- 如果一个键只对应一个值，使用 `map` 或 `unordered_map`；如果一个键对应多个值，使用 `multimap`。

### 14.4 综合性能对比

| 容器类型          | 插入复杂度       | 查找复杂度       | 顺序性       | 适用场景简述                       |
|-------------------|------------------|------------------|--------------|-----------------------------------|
| `vector`          | O(1) 均摊（尾部）| O(n)            | 有序（插入序）| 动态数组，随机访问，顺序存储      |
| `deque`           | O(1)（两端）     | O(n)            | 有序（插入序）| 双端队列，两端操作               |
| `stack`           | O(1)            | 不支持查找       | LIFO         | 后进先出，模拟栈                 |
| `queue`           | O(1)            | 不支持查找       | FIFO         | 先进先出，层次遍历               |
| `priority_queue`  | O(log n)        | O(1)（堆顶）     | 部分有序      | 动态维护最大/最小值              |
| `set`             | O(log n)        | O(log n)        | 有序（升序）  | 有序去重，快速查找               |
| `unordered_set`   | O(1) 平均       | O(1) 平均       | 无序          | 快速去重，快速查找               |
| `map`             | O(log n)        | O(log n)        | 有序（键升序）| 有序键值映射，快速查找           |
| `unordered_map`   | O(1) 平均       | O(1) 平均       | 无序          | 快速键值映射，快速查找           |
| `multiset`        | O(log n)        | O(log n)        | 有序（升序）  | 有序可重复，频率统计             |
| `multimap`        | O(log n)        | O(log n)        | 有序（键升序）| 有序多值映射，一个键多个值       |

**选择建议**：
- **快速查找**：优先考虑 `unordered_set` 或 `unordered_map`，若数据分布不均或需最坏情况保证，使用 `set` 或 `map`。
- **顺序存储**：优先考虑 `vector`，若需两端操作使用 `deque`。
- **动态优先级**：使用 `priority_queue` 维护最大/最小值。
- **可重复元素**：若需统计频率或多值映射，使用 `multiset` 或 `multimap`。




为甚么需要迭代器？
很多数据结构并不是线性的（例如红黑树），对于非线性结构，下标是无意义的，无法使用下标来遍历整个数据结构。迭代器的作用就是定义莫个数据结构的遍历方式，通过迭代器的增减，代表遍历的位置，通过迭代器便能成功遍历非线性结构了。

推荐不使用迭代器来操作容器内容。



常用算法：

```

## 15. 常用算法

### 15.1 排序算法

#### sort
- **功能**：对容器进行排序
- **用法**：`sort(迭代器开始, 迭代器结束, [比较函数])`
- **复杂度**：O(n log n)
- **示例**：
  ```cpp
  vector<int> v = {3, 1, 4, 1, 5, 9};
  sort(v.begin(), v.end());  // 升序排序
  sort(v.begin(), v.end(), greater<int>());  // 降序排序
  ```

#### stable_sort
- **功能**：稳定排序，相等元素相对位置不变
- **用法**：`stable_sort(迭代器开始, 迭代器结束, [比较函数])`
- **复杂度**：O(n log n)
- **适用场景**：需要保持相等元素相对顺序的场景

### 15.2 查找算法

#### binary_search
- **功能**：二分查找元素是否存在
- **用法**：`binary_search(迭代器开始, 迭代器结束, 值)`
- **复杂度**：O(log n)
- **前提**：容器必须已排序
- **示例**：
  ```cpp
  vector<int> v = {1, 2, 3, 4, 5};
  bool found = binary_search(v.begin(), v.end(), 3);  // true
  ```

#### lower_bound / upper_bound
- **功能**：查找第一个不小于/大于指定值的位置
- **用法**：
  - `lower_bound(迭代器开始, 迭代器结束, 值)`
  - `upper_bound(迭代器开始, 迭代器结束, 值)`
- **复杂度**：O(log n)
- **前提**：容器必须已排序
- **示例**：
  ```cpp
  vector<int> v = {1, 2, 2, 2, 3, 4};
  auto it1 = lower_bound(v.begin(), v.end(), 2);  // 指向第一个2
  auto it2 = upper_bound(v.begin(), v.end(), 2);  // 指向3
  ```

### 15.3 数值算法

#### accumulate
- **功能**：计算容器元素的和
- **用法**：`accumulate(迭代器开始, 迭代器结束, 初始值)`
- **复杂度**：O(n)
- **示例**：
  ```cpp
  vector<int> v = {1, 2, 3, 4, 5};
  int sum = accumulate(v.begin(), v.end(), 0);  // 15
  ```

#### max_element / min_element
- **功能**：查找最大/最小元素的位置
- **用法**：
  - `max_element(迭代器开始, 迭代器结束)`
  - `min_element(迭代器开始, 迭代器结束)`
- **复杂度**：O(n)
- **示例**：
  ```cpp
  vector<int> v = {3, 1, 4, 1, 5, 9};
  auto max_it = max_element(v.begin(), v.end());  // 指向9
  auto min_it = min_element(v.begin(), v.end());  // 指向第一个1
  ```

### 15.4 修改算法

#### reverse
- **功能**：反转容器元素顺序
- **用法**：`reverse(迭代器开始, 迭代器结束)`
- **复杂度**：O(n)
- **示例**：
  ```cpp
  vector<int> v = {1, 2, 3, 4, 5};
  reverse(v.begin(), v.end());  // {5, 4, 3, 2, 1}
  ```

#### unique
- **功能**：去除相邻重复元素
- **用法**：`unique(迭代器开始, 迭代器结束)`
- **复杂度**：O(n)
- **前提**：容器必须已排序
- **示例**：
  ```cpp
  vector<int> v = {1, 1, 2, 2, 3, 3, 3, 4};
  auto it = unique(v.begin(), v.end());  // 返回新结束位置
  v.erase(it, v.end());  // 删除多余元素
  ```

#### fill
- **功能**：用指定值填充容器
- **用法**：`fill(迭代器开始, 迭代器结束, 值)`
- **复杂度**：O(n)
- **示例**：
  ```cpp
  vector<int> v(5);
  fill(v.begin(), v.end(), 42);  // {42, 42, 42, 42, 42}
  ```

### 15.5 排列算法

#### next_permutation / prev_permutation
- **功能**：生成下一个/上一个排列
- **用法**：
  - `next_permutation(迭代器开始, 迭代器结束)`
  - `prev_permutation(迭代器开始, 迭代器结束)`
- **复杂度**：O(n)
- **返回值**：如果存在下一个/上一个排列返回true，否则返回false
- **示例**：
  ```cpp
  vector<int> v = {1, 2, 3};
  do {
      for(int x : v) cout << x << " ";
      cout << endl;
  } while(next_permutation(v.begin(), v.end()));
  ```

### 15.6 算法复杂度总结

| 算法              | 时间复杂度       | 空间复杂度 | 适用场景                     |
|-------------------|------------------|------------|------------------------------|
| `sort`            | O(n log n)       | O(log n)   | 一般排序                     |
| `stable_sort`     | O(n log n)       | O(n)       | 需要稳定排序                 |
| `binary_search`   | O(log n)         | O(1)       | 在有序容器中查找             |
| `lower_bound`     | O(log n)         | O(1)       | 查找插入位置                 |
| `upper_bound`     | O(log n)         | O(1)       | 查找插入位置                 |
| `accumulate`      | O(n)             | O(1)       | 计算元素和                   |
| `max_element`     | O(n)             | O(1)       | 查找最大元素                 |
| `min_element`     | O(n)             | O(1)       | 查找最小元素                 |
| `reverse`         | O(n)             | O(1)       | 反转元素顺序                 |
| `unique`          | O(n)             | O(1)       | 去除相邻重复元素             |
| `fill`            | O(n)             | O(1)       | 填充容器                     |
| `next_permutation`| O(n)             | O(1)       | 生成排列                     |

### 15.7 算法使用注意事项

- **迭代器有效性**：使用算法时要注意迭代器的有效性，避免使用已失效的迭代器。
- **比较函数**：自定义比较函数时要确保严格弱序，避免未定义行为。
- **容器要求**：某些算法对容器有特定要求（如已排序），使用前要确认。
- **性能考虑**：对于大数据量，要考虑算法的复杂度，选择合适的算法。

---

## 16. 总结

本文档详细介绍了算法竞赛中常用的 STL 容器和算法，包括：

### 16.1 容器选择指南

- **动态数组**：`vector` - 最常用的序列容器
- **栈和队列**：`stack`, `queue` - 模拟栈和队列操作
- **优先队列**：`priority_queue` - 动态维护最大/最小值
- **有序集合**：`set`, `map` - 需要排序和去重的场景
- **无序集合**：`unordered_set`, `unordered_map` - 快速查找，不关心顺序
- **双端队列**：`deque` - 需要在两端高效操作的场景
- **多重容器**：`multiset`, `multimap` - 允许重复元素的场景

### 16.2 算法选择指南

- **排序**：`sort` - 一般排序，`stable_sort` - 稳定排序
- **查找**：`binary_search`, `lower_bound`, `upper_bound` - 二分查找
- **数值计算**：`accumulate`, `max_element`, `min_element` - 数值操作
- **修改操作**：`reverse`, `unique`, `fill` - 容器修改
- **排列生成**：`next_permutation`, `prev_permutation` - 排列组合

### 16.3 性能优化建议

- **预分配空间**：对于 `vector`，使用 `reserve()` 预分配空间
- **避免频繁插入删除**：在 `vector` 中间位置频繁插入删除效率较低
- **选择合适的容器**：根据具体需求选择合适的容器类型
- **注意算法复杂度**：在大数据量下要考虑算法的复杂度

### 16.4 常见错误避免

- **迭代器失效**：在遍历过程中修改容器结构
- **未检查边界**：使用 `top()`, `front()` 等操作前未检查容器是否为空
- **比较函数错误**：自定义比较函数不符合严格弱序
- **内存管理**：对于 `vector`，`clear()` 不会释放内存

通过合理使用 STL 容器和算法，可以大大提高算法竞赛中的编程效率和代码质量。
