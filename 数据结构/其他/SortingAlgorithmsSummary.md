# 排序算法总结与对比

## 概述

排序算法是计算机科学中最基础也是最重要的算法之一。本文档总结了常见的排序算法，包括它们的特点、复杂度分析、适用场景等。

## 排序算法分类

### 按时间复杂度分类

| 类别 | 时间复杂度 | 代表算法 |
|------|------------|----------|
| O(n²) | 平方级 | 冒泡排序、选择排序、插入排序 |
| O(n log n) | 对数级 | 快速排序、归并排序、堆排序 |
| O(n) | 线性级 | 计数排序、桶排序、基数排序 |

### 按稳定性分类

| 类别 | 特点 | 代表算法 |
|------|------|----------|
| 稳定排序 | 相等元素相对位置不变 | 冒泡排序、插入排序、归并排序 |
| 不稳定排序 | 相等元素相对位置可能改变 | 快速排序、堆排序、选择排序 |

## 详细算法对比

### 1. 冒泡排序 (Bubble Sort)

**复杂度分析**：
- 时间复杂度：O(n²) 平均和最坏，O(n) 最好
- 空间复杂度：O(1)
- 稳定性：稳定

**特点**：
- ✅ 简单直观，易于实现
- ✅ 原地排序，空间复杂度低
- ✅ 稳定排序
- ❌ 时间复杂度高，不适合大规模数据
- ❌ 交换次数多

**适用场景**：
- 教学演示
- 小规模数据排序
- 需要稳定排序的场景

### 2. 选择排序 (Selection Sort)

**复杂度分析**：
- 时间复杂度：O(n²) 所有情况
- 空间复杂度：O(1)
- 稳定性：不稳定

**特点**：
- ✅ 简单直观
- ✅ 原地排序
- ✅ 交换次数少
- ❌ 时间复杂度高
- ❌ 不稳定排序

**适用场景**：
- 交换成本高的环境
- 小规模数据排序

### 3. 插入排序 (Insertion Sort)

**复杂度分析**：
- 时间复杂度：O(n²) 平均和最坏，O(n) 最好
- 空间复杂度：O(1)
- 稳定性：稳定

**特点**：
- ✅ 简单直观
- ✅ 原地排序
- ✅ 稳定排序
- ✅ 对于已排序数据效率高
- ✅ 在线算法
- ❌ 时间复杂度高

**适用场景**：
- 小规模数据排序
- 部分排序的数据
- 在线排序需求

### 4. 快速排序 (Quick Sort)

**复杂度分析**：
- 时间复杂度：O(n log n) 平均，O(n²) 最坏
- 空间复杂度：O(log n) 平均，O(n) 最坏
- 稳定性：不稳定

**特点**：
- ✅ 平均情况下效率高
- ✅ 原地排序（优化版本）
- ✅ 缓存友好
- ❌ 最坏情况下效率低
- ❌ 不稳定排序

**适用场景**：
- 大规模数据排序
- 对平均性能要求高的场景

### 5. 归并排序 (Merge Sort)

**复杂度分析**：
- 时间复杂度：O(n log n) 所有情况
- 空间复杂度：O(n)
- 稳定性：稳定

**特点**：
- ✅ 时间复杂度稳定
- ✅ 稳定排序
- ✅ 适合外部排序
- ✅ 并行性好
- ❌ 空间复杂度较高
- ❌ 小数据效率低

**适用场景**：
- 外部排序
- 链表排序
- 需要稳定排序的大规模数据

### 6. 堆排序 (Heap Sort)

**复杂度分析**：
- 时间复杂度：O(n log n) 所有情况
- 空间复杂度：O(1)
- 稳定性：不稳定

**特点**：
- ✅ 时间复杂度稳定
- ✅ 原地排序
- ✅ 适合优先级队列
- ❌ 不稳定排序
- ❌ 缓存不友好

**适用场景**：
- 优先级队列实现
- Top K 问题
- 内存受限的环境

## 性能对比表

| 算法 | 平均时间 | 最坏时间 | 最好时间 | 空间复杂度 | 稳定性 | 原地排序 |
|------|----------|----------|----------|------------|--------|----------|
| 冒泡排序 | O(n²) | O(n²) | O(n) | O(1) | ✅ | ✅ |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | ❌ | ✅ |
| 插入排序 | O(n²) | O(n²) | O(n) | O(1) | ✅ | ✅ |
| 快速排序 | O(n log n) | O(n²) | O(n log n) | O(log n) | ❌ | ✅ |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | ❌ |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | ✅ |

## 算法选择指南

### 根据数据规模选择

**小规模数据 (n < 50)**：
- 插入排序：简单高效
- 冒泡排序：教学演示
- 选择排序：交换成本高时

**中等规模数据 (50 ≤ n < 1000)**：
- 快速排序：平均性能好
- 归并排序：需要稳定性
- 堆排序：内存受限

**大规模数据 (n ≥ 1000)**：
- 快速排序：首选
- 归并排序：外部排序或需要稳定性
- 堆排序：优先级队列需求

### 根据特殊需求选择

**需要稳定排序**：
1. 归并排序
2. 插入排序
3. 冒泡排序

**内存受限**：
1. 堆排序
2. 快速排序
3. 插入排序

**在线排序**：
1. 插入排序
2. 堆排序

**外部排序**：
1. 归并排序
2. 堆排序

## 混合排序策略

### Introsort（内省排序）
结合快速排序、堆排序和插入排序的优点：

```cpp
class Introsort {
public:
    static void sort(std::vector<int>& arr) {
        int maxDepth = 2 * log2(arr.size());
        introsort(arr, 0, arr.size() - 1, maxDepth);
    }

private:
    static void introsort(std::vector<int>& arr, int left, int right, int depth) {
        int size = right - left + 1;
        
        // 小数组使用插入排序
        if (size <= 16) {
            insertionSort(arr, left, right);
            return;
        }
        
        // 深度过大时使用堆排序
        if (depth == 0) {
            heapSort(arr, left, right);
            return;
        }
        
        // 否则使用快速排序
        int pivot = partition(arr, left, right);
        introsort(arr, left, pivot - 1, depth - 1);
        introsort(arr, pivot + 1, right, depth - 1);
    }
};
```

### Timsort
Python 内置的排序算法，结合归并排序和插入排序：

```cpp
class Timsort {
public:
    static void sort(std::vector<int>& arr) {
        const int MIN_MERGE = 32;
        int n = arr.size();
        
        // 小数组直接使用插入排序
        if (n < MIN_MERGE) {
            insertionSort(arr, 0, n - 1);
            return;
        }
        
        // 寻找自然运行
        std::vector<std::pair<int, int>> runs;
        int start = 0;
        
        while (start < n) {
            int end = findRun(arr, start, n);
            runs.push_back({start, end});
            start = end + 1;
        }
        
        // 合并运行
        while (runs.size() > 1) {
            for (size_t i = 0; i < runs.size() - 1; i += 2) {
                mergeRuns(arr, runs[i], runs[i + 1]);
            }
        }
    }
};
```

## 实际应用建议

### 1. 通用场景
对于大多数应用，推荐使用以下策略：
- **标准库排序**：`std::sort()`（通常是快速排序的优化版本）
- **稳定排序**：`std::stable_sort()`（通常是归并排序）
- **部分排序**：`std::partial_sort()`（堆排序）

### 2. 特殊场景
- **内存受限**：堆排序
- **外部排序**：归并排序
- **小规模数据**：插入排序
- **教学演示**：冒泡排序

### 3. 性能优化
- **混合策略**：结合多种算法的优点
- **缓存优化**：考虑数据局部性
- **并行化**：利用多核处理器

## 总结

选择合适的排序算法需要考虑以下因素：

1. **数据规模**：小规模、中等规模、大规模
2. **稳定性要求**：是否需要保持相等元素的相对位置
3. **内存限制**：可用内存大小
4. **性能要求**：平均性能 vs 最坏性能
5. **实现复杂度**：开发时间和维护成本

在实际应用中，通常优先使用标准库提供的排序函数，它们已经经过充分优化。只有在特殊需求下才需要自己实现特定的排序算法。 