## 泛型类型

除了泛型函数之外，Go 还支持泛型类型。 类型可以使用类型参数进行参数化，这对于实现通用数据结构非常有用。

此示例展示了能够保存任意类型值的单链表的简单类型声明。


```go
package main

import "fmt"

// List 表示一个可以保存任何类型的值的单链表。
type List[T any] struct {
	next *List[T]
	val  T
}

// NewList 创建一个新链表，返回头节点指针（初始为 nil）
func NewList[T any]() *List[T] {
	return nil
}

// PushFront 在链表头部插入一个新值，返回新的头节点
func (l *List[T]) PushFront(val T) *List[T] {
	newNode := &List[T]{
		next: l,
		val:  val,
	}
	return newNode
}

// Length 返回链表长度
func (l *List[T]) Length() int {
	count := 0
	for curr := l; curr != nil; curr = curr.next {
		count++
	}
	return count
}

// Print 打印链表中的所有值（需要类型支持 %v 输出）
func (l *List[T]) Print() {
	fmt.Print("[")
	for curr := l; curr != nil; curr = curr.next {
		fmt.Print(curr.val)
		if curr.next != nil {
			fmt.Print(" -> ")
		}
	}
	fmt.Println("]")
}

// ToSlice 将链表转换为切片，便于使用
func (l *List[T]) ToSlice() []T {
	var slice []T
	for curr := l; curr != nil; curr = curr.next {
		slice = append(slice, curr.val)
	}
	return slice
}

// Contains 检查链表是否包含某个值（要求 T 支持 == 比较）
// 注意：Go 泛型中要支持 ==，应使用 ~constraints.Ordered 或直接 any，但需值可比较
func (l *List[T]) Contains(val T) bool {
	for curr := l; curr != nil; curr = curr.next {
		if curr.val == val { // 要求 T 是可比较类型（如 int, string 等）
			return true
		}
	}
	return false
}

func main() {
	// 创建空链表（nil）
	var list *List[int]

	// 插入一些值
	list = list.PushFront(3)
	list = list.PushFront(2)
	list = list.PushFront(1)

	// 测试功能
	list.Print()           // [1 -> 2 -> 3]
	fmt.Println("Length:", list.Length()) // Length: 3

	slice := list.ToSlice()
	fmt.Println("Slice:", slice) // Slice: [1 2 3]

	fmt.Println("Contains 2?", list.Contains(2)) // true
	fmt.Println("Contains 5?", list.Contains(5)) // false

	// 再试试字符串类型的链表
	var strList *List[string]
	strList = strList.PushFront("world")
	strList = strList.PushFront("hello")

	strList.Print() // [hello -> world]
}
```